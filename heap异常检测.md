# heap异常检测

## 主要文件

kfence.h —— 这里定义，方便其他文件引用，感觉没什么要引用的，其实写core里也行，不过为了规范还是单独写出

core.c —— 程序核心代码

report.c —— 报告生成模块

Makefile —— 编译相关

.config —— 配置相关

## 程序实现

1. 初始化
   
   将kfence自己hook到slub/slab中（函数指针实现）
   
   申请kfence内存池，占用的内存计算公式为：( 页数 + 1 ) x 2 x 页面大小
   
   将第0页和基数页设置为保护页即red-zone（访问保护）
   
   设置一个计时器

2. 分配内存
   
   当程序申请内存时，若计时器就绪，申请的内存大小小于kfence页面大小并且kfence有空闲页时，分配kfence数据页，否则进行正常内存分配

3. 填充canary
   
   当分配kfence数据页后，如果申请的内存大小小于页面大小，则将剩余的部分填充canary，等待释放时检查该区域是否合法，从而判断有无越界情况

4. 释放内存
   
   释放后设置为保护页，访问立即触发异常

## 主要参数

1. 数据页大小：检测粒度

2. 数据页数量：性能开销

3. 计时器：抽样速度（检测密度）

## 异常类型

1. out-of-bounds（OOB）——越界访问：不管分配的数据内存多大，都会占用一个数据页（填充canary区域），当原本访问数据的操作溢出到保护页时，触发异常，如果是溢出到canary上，则需要等到释放时验证

2. use-after-free（UAF）——释放后使用：当内存释放后对该内存区域设置为保护页，当再次访问时触发异常

3. invalid-free（INVALID）——非法释放：

## 思路

1. （基础实现）

2. （适当时机触发检测）：对内存泄漏每个特征进行加权，当权重达到一定数值时触发检测，要求用户能够简单配置，打个比方说我某个程序一直重复申请内存，到达一定值我给他检测一下，用户配置的话感觉挺好解决，权值表直接写配置文件里，设个默认值，要改配置的时候改一下就行
